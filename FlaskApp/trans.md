All right. It's 12, 30 and happy new year. Welcome to CS 340. This is the Introduction to Computer Systems. So I am happy to see all of you guys here. One thing, logistically before we get started is I have a handout on that. We'll talk about exactly how we'll use these. But this handout is available at the very back of the classroom. So if you don't have one, you can grab one there. I have a few. If you're upfront, I can grab you. Get you one. I think I got most of the rows. So if you need a handout, you can find them right back in that back corner, right as you're walking into the corner of that table. Um, so there should be a pile of them back there. Hopefully. You Thank you for saving me. I would have been looking for that. Genuine. Awesome. Are there still some in the back? There are. Perfect. Awesome. So every day that'll be in the back. So we are all good. So I wanted to welcome you to 340. This is, I think one of the most important courses you'll take here at the University of Illinois. But I don't want to get too far started into the logistics because I think what really matters more than anything is that no good party starts without introductions. I wanna get to know you guys in a second, just to give a one-minute overview of who you're gonna see in front of the room. So I'm waiting on Scheiner. I'm teaching faculty here at the Department of Computer Science at the University of Illinois and the Granger College of Engineering. The same place you guys are at. I've done a bunch of different work in a bunch of different areas. So I have worked at a bunch of big tech companies. I spent time at Cisco, has spent time at Google, I spent time at Morgan Stanley and really wanted to make a difference and change the world. So I ended up go into academia where I could actually decide where I want to spend my time and create projects that have larger impact and hopefully make your lives better. Hopefully you've seen some of my visualizations, whether or not it's visualizations that work on explaining the COVID pandemic in a data forward way or visualization. You explain the GPA and your GPA visualizations that you can understand the overview of each courses, um, and then I teach a bunch of different courses. So I've taught 225, I've taught 340, I've taught the previous 340, which is 240. I'm working on new data science course and I've got a number of online courses on the Coursera platform. So one thing I'm super passionate about is just being able to share technology and to make you the very best programmers in the world. Because I have a PhD from the University of Illinois. And I believe that when a line I are doing the best and we know lionized succeeds, it makes us all look better. And you'll see one thing that underlines this entire semester is that we're going to create a sense of community. That here we're going to work together and building up big scale systems, not against each other. There's gonna be collaboration, There's gonna be helping each other out. That the real goal of this class is for you to become the very best programmer in the world. So what I wanna do is kitchen know each of you a little bit because I feel like this class is really unique. You'll get to know two additional people. We've got two TAs, we may be getting a third TA. They're going to really be the, kinda the leads of the MPs. They're gonna be your technical support so you'll get to know them. You'll see them bunch in office hours. So you will get two. We'll have them introduce themselves as it gets further into the semester. But I want to, and then there's a whole team of course assistants and we will also let you guys get, you know, this is amazing. Some of the best team, they're the best team I've ever had. So they are an awesome group of people and they're gonna help you out through this journey. But the most important person in the room is you. And I love this class. This class is particularly awesome because there's such a diversity of passion and interests in this room. There are more majors represented here and more colleges represented here than probably in almost any other classroom at Illinois. So I know the one thing that unifies most of you is you're probably a CS plus. But what pluses are you? I'm just curious, as a survey, who is CS stat? Okay, so we've got some SEO stats, CS math. Okay, we have some CS math, so that maybe accounts for about half the room. And I don't think I did you raise your hand? What major you see us philosophy. Who's the CFO philosophies in here? Awesome. Do you guys know each other? Okay, guys, you need to have all meet each other because you all sat in the same spot. You're thinking alike. You guys should become DFFs. So CS philosophy, we've got CPS philosophy crew down here. Who else has not had their major, who have not raised their hand for their major? Yeah. What's your major? Cs plus chemistry. Who else are the chemists in this room? You guys know each other. Know. Oh, okay, this is a problem, guys. Alright. You guys become DFFs as well, like CS, chemistry, you're both in here. You guys are going to know more about how molecules bind together and then I have forgotten. So you guys are gonna be geniuses there and I think chemistries that future. Alright, so we've got chemistry, we've got Philosophy, we've got math, we've got statistics. Who else have I not supposed to econ, who's the economists? Awesome. Do you guys know each other? Weight? Sitting next to each other? Don't know what each other. Alright, you guys, what's your name? Rohit. Love Rohit. Nice to meet you at the other Awesome icon as well. No, sorry. Who else? I knew somebody someone else was Econ. Those behind me. Oh, sorry. I was wondering off Awesome. Any other CSE cons? This is so awesome. We've got all these different groups of people who else? What other x majors, what other majors do we have in this room? Yeah, back row in the Hat. Arrows, straight up aerospace. Oh, nice. Okay. Who is not a CS plus major? Who is a major of something other than cs plus? So we've got the aerospace IS mechanical. Awesome. Oh, no. Okay. So a bunch of different non majors. I know we've gotten a few people. I haven't heard from everyone yet. Who else has not had their major cs plus education. That is awesome. Any other CS plus education majors in here? I think that's brand new. There's like six of you, right? Yeah. So that's awesome. I think it's gonna be huge in the future, so awesome. Any others? Yeah, way back. Cs plus advertise that pupil is going to make all the money. All right. Who else is going to be future google employees? Who cs plus advertising? Wait, oh, hey, awesome. One to any other CS advertising's awesome. Another one. You guys know each other yet. You guys know each other. Congratulation to first people to answer that question. That's amazing. Awesome. Any others? We'll do one more. Is there anyone who I'm missing? Yeah. Yes. What's what? Here? One more time. Music. Cs plus music. What instrument do you play? Viola. Awesome. Any other CS musicians? Yeah. Oh, what's your instrument? Piano, nice. I mean, I feel like no other class do you get this diversity of people who are just like super passionate about these other areas. Like the reason that I teach data science course, the reason I teach CS plus X courses, the reason I built 340 is because I think being able to be really passionate in another area. And then applying computing on top of that is what's going to change the world the next 20 years. I think you guys are in the best majors possible and best positioned to actually make a huge difference in the world. And I feel like everything I've done has always been applied computer science as well. So I feel right at home. And if I was an undergraduate, if I was in your seats, I think I would be a CS major as well. So I love the I love that you guys have all of these different interests, all of these different passions. And my goal is to try and have you learn the best computer science you can explore your passions through computing. So I've got a few questions. Let's get some more interesting questions. Maybe something a little provocative. Iphone or Android. Who is team iPhone? Whoa. Okay. Guys, I have an Android. So who's with me? Wow, wait, are they still doing Android programming? And when 24, I missed the audience. Okay, yeah, this is definitely a team. Iphone semester crazy. But even though you're all iPhone users, macOS versus Windows, Windows users, Steve Jobs not doing great job. Who is macOS users? Whose primary system is running on Linux? There's always one. Awesome. You moved to or something else. Mostly meant awesome. So we've got a number of different platforms. In general, we're going to support both Windows and OSX. You're gonna be a little bit on your own to get things to compile. But I think if you're using mint, you're pretty good on that. So we'll have our makefiles and everything we distribute should just work on Windows and Mac, just fine. There may be a few things for math. You have to do something very, something slightly different, but we'll guide you through anytime that there's a difference. So I am one other question. I always love to hear about where people got to go. So I'm wondering who left the United States. During this winter break. So who left the US? Traveled over c over to another country at all? Awesome. Okay. A few of you guys who left the state of Illinois. Okay, almost, I'd say a good like 60, 70% of you guys. And so I have another slightly provocative question. What right now is your favorite programming language? So I'm just going to have, so what is your, do you mind sharing what your favorite programming languages? Python, okay, That's a great answer. We're gonna do Python for the second half of the semester. So who shares this idea of Python being their favorite programming language? Whose team? Python. Oh, not that many people. Okay, Python, I feel like going down. Interesting. Alright, You're not Python. What team are you? C plus plus. Whose teams? C plus plus is their favorite programming language. Quite a few C Plus Plus programmers, awesome. Somebody. Have you mentioned a favorite. You said C Plus Plus Python. C plus plus C plus. I pick the wrong row. Python. Oh, Java, okay, a throwback to the one-two-three-four, 125 days, whose team, Java's their favorite programming language. Oh, a few. I used to, I used to agree. You know, my favorite programming language is somewhat related to Java in name only. Who is team JavaScript or TypeScript? I like, I like it. Guys. If there's anything I can do is maybe make you fall in love with TypeScript. It's amazing. It's my favorite language. We had a lot of people who love C plus, plus. What about C? Is there anyone who prefers Cs over C plus plus? You just like rust. A few CC plus, plus. How about people who like Rust or carbon? Or what's the third one in that category? What's the Google language? Go, Rusk, Russ carpenter go. One of these kinda new systems alternatives. Which one? Go? Awesome. Anyone else who has another programming language we didn't mentioned? There's someone who yeah, Kotlin, java alternative. Anyone's team Kotlin? Yeah, it's about as popular as Java. So a lot of different programming language, a lot of C plus, plus a lot of Python. So we're gonna do Python for the second half of the semester. We're going to do C without the plus, plus and the first half of the semester. My goal is for you to maybe fall in love with the simplicity of C. I think you'll see a lot of that. So we've got a lot of different interests, a lot of different kind of background. Do you guys have any questions you're dying to know about everyone else in this room? Anything you want to ask? How many asked everyone? Yeah. What's your PhD in? No. Ask each other. My PhD is in computer science, but that's boring. I can tell you all about kernel network, wireless devices and all sorts of stuff. But anything you are dying to ask about each other, like spaces versus tabs. Whose team spaces? Whose team tab? Wow. Okay. I feel like 20% of yours, like, I don't care. Any question like that. School? Yeah. Oh, that's an amazing question. So how many of you guys are? This is a confusing question to ask students because you're all seniors, I know. But how many of you guys are in your fourth year of college? Any like fourth-year? Any like seniors by year. Okay. A few. How many guys are in your third year? You're like junior year. By junior cohort maybe is the way that CSS it. Awesome. How many guys are in second year? Okay. A lot of and how many is there anyone who just got here and just randomly ended up here in their second semester in college. Congratulations. So a few freshmen by year. Are you also first-year? No. Okay. Awesome. The There's a whole diversity. We've got everyone from sophomores, juniors, seniors to freshmen, a lot of different people in a lot of different years. Great question. Last question. Any one? Last question? For the entire class? Yeah. Oh, that's a great question. Are you Team light mode? Are you Team dark mode? So whose team light mode? Wow. Who seemed dark mode? Holy crap. Alright, I needed to make all my visualizations black from now on out. So clearly light mode is out. Light mode deleted. Why even have a light mode, we'll just call it, we'll call it a normal mode now. So awesome. One thing I want to make sure you do is you get to know, get to know each other. Part of the reason I'm going through this is beginning to have a little bit of a course community getting to know each other. And we're going to do a lot of that throughout lecture in 340. And that will extend onto office hours and onto our discord. What I already know about you, in addition to the questions that I just answered was that you guys are absolutely experts at programming. So I've heard from a lot of your previous professors that you guys are the best cohort of students they've ever had. So I was talking to evans the other day and he's like, last semester is true, 25 was the best to 25 he's ever taught. I'm guessing most of you were part of that class. So I already know you guys are experts, C Plus, Plus programmers. But I also know is that you understand the theory behind everything you learned into 25 as well, the, you know, data structures. I'm not going to repeat what a heap is, or a stack, or a binary tree or an AVL tree, all of that stuff. I'm just going to assume, you know, we're not going to review any of it because you guys can look it up if you've forgotten any of it. But you guys have mastered this context. I also know by talking to Margaret flag, professor Fleck, as well as the other instructors who have taught and taught 173, is that you guys have a great master of discrete mathematics. They're able to do proofs. You're able to do prove things by induction that you dream and inductive proofs. So I also know from talking to Jeff and Michael Novak and all of the other people who teach. I'm Professor Lewis, that you guys know really great foundational programming skills. In fact, Is there any one of you who have taken has has anyone taken one-twenty five or you guys all the one-two-three-four 128 now, anyone who's taken one-twenty, so a couple of one-to-five are still left. Awesome. So I think 120-50-1205. So few people left in 125. Most of you guys have now gone through the one-two-three-four, one-two-three-four. The new kind of model for the programming courses. So I know you don't know, I know you know how to program. I know you know how to program in C plus plus. And I know that you understand the foundations of everything you've programmed. So now that you're in a 300 level class, we're not going to be reading you along the way and helping you and telling you exactly what to do. In 225, which I used to teach that course. I know exactly what's going on in that course. I think my name is still on random different things you gotta do. I know that we lead you through doing the assignments. You're going to have a different experience here. And in 340, we're, we're gonna give you what you want to accomplish, but not how to accomplish it. We're going to give you a high-level design and you're going to implement the high-level design rather than being told what to do. Like an MP mosaics from last semester. You guys are still doing the mosaics, right? Yeah. We pretty much tell you, like literally convert this written English text into code. Like there's not much kind of design on building that Katie tree. In this class will tell you pay your building on Mosaic. Do it. You'll get it figured out design. You'll get to solve that puzzle. It's a lot of fun. So after you've finished this course, you're gonna know a tiny bit about foundational computer architecture. I want to make sure computer doesn't feel like a black box. We're not gonna go into exactly how the CPU's design. We're not gonna go into all of the crazy bits at 02:33 teachers. Because this class is going to take its name. It's numbered 340 because it sort of takes 233.3, 41 and smashes them together. But we're not really meeting in the middle. The course wasn't named to 37. There was named to 43, 40 because it's really taking about one-seventh of 233. And give you the important high-level details of stuff that you'd actually use the computer scientists. And we'll spend about two or three weeks just doing the foundational architectural stuff. After that, we want to move and understand how the operating system works. Doing OS design, you're going to encompass everything that 341 does the other systems course. And we're going to do that in about half the amount of time. We're going to take out things that aren't that relevant to modern systems anymore. E.g. I. Don't think you ever care about how hard disk is actually spin and where to locate a file on a spinning hard disk. It's important if you're doing large-scale file storage, not so important if you're working in the Cloud. You understand how process it works, how threads work, how to do async await, how promises end up working, how futures end up working. All of the different concepts you see about synchronization that you may have seen if you've done any other programming. And we're going to talk about multiprogramming, the idea of having multiple threads and multiple processes working together to accomplish something big. The sharing of resource that happened around that. So how do you ensure that when you write something to a database, that if four different cloud-based services are already at the same time, how do you ensure that the data they're all writing is getting committed? Or what do you do if you can't commit all of the data because they arrive at exactly the same time. How do you lock? So how do you resource sharing? Where the best practices in that area? And then at about the halfway point, we're going to have a midterm exam and we're going to end with our C programming. First half of this course is seen systems-based. Then we're going to transition over to the Cloud. Because what I bet, I bet most of you will be building applications just don't run on a single computer. When we talk about systems, we often talk about what's running on your phone all by itself without communicating with the outside world or what's running on your laptop all by itself without communicating with the outside world. But in reality, you may all be using an app that's all communicating with the server. So what are Cloud-based infrastructure that you'd want to use? How do we build a microservice? What is microservice design even mean? And if you've got millions of users, how do you scale it? So your one server doesn't just fall apart. How to use things like S3 or database services or CDNs, content delivery networks. How do you use all of his cloud-based infrastructure so you can deploy a global-scale application. And the very final thing we're gonna do is my goal for the final project this semester is we're gonna be building something together where every single one of you are going to contribute to a piece of a project that we're going to have running at the final exam. So that means if any one of your project doesn't work, the whole final exam won't be 100%. Not for grading. Don't worry about that. You're not dependent on other people for that. But you're going to see the system could function better if all the nodes were connected. So you're gonna be part of a system and seeing that your contribution to the system that involves 200 different nodes all going to work together because all of you are part of a system. So each of you will be running a small Microservice part of a huge system. Every semester we do something different. So we'll talk about some of the previous semesters work that some of the final projects I worked with previous students on. But I think this final project is gonna be the best final project yet. So if you ideas of what you want to build, let me know. I literally don't have a clue what we're gonna do. We're gonna kinda organically come up with it. We're going to see what you're interested in. Maybe we'll mute music-related. Maybe I'll be chemistry related. We'll do something that involves all of us collaborating on one big system. So all of that, the core structure is pretty straightforward. There's lectures every Tuesday, Thursday. So every day you will get a handout. And this handout will guide you through it. You're going to see that it looks very similar to what I did in 225. So here's my older 25 handouts. You're going to see that they've repeated over to the style. That's one of the things I got the best piece of feedback from 225 form. So I kinda moved it over to 340. So you'll see these very similar style handouts. What I'll do is I'll go through each handout, will get completely through every single handout. Every day is my goal. If we don't have like the very last section done, we'll finish that up. So we'll never skip apart on a handout. Everything on the handouts there to guide you handout. They'll sometimes be pre-lecture readings for you to kind of read over facts and basic concepts in systems programming. Because me sharing you man, pages, which are manual pages, are old Linux term. Or sharing facts. Isn't that interesting? I want to share high-level design details and any of the background reading will prepare you for that. So every single day I will post the handouts before lecture. I usually post it sometime the night before. So you can print out a copy of yourself. I'll have some pronounced in the back and they'll always be on the course website. So you'll be able to download it to your own computer if you want to type notes on that or use a stylus to Mark, mark it up. So you'll always have a PDF copy of this available for you. There is a machine problem and a least one homework every single week. So there's a new MP every week. The key idea of this course is really understanding systems programming. I think me standing up here and telling you how a process works is not nearly as valuable as you actually programming code. So you going through there, you running processes, using processes fail, you seeing things crash, you see things seg fault, you fix those seg faults. You understand how they work together. You're doing stuff is the best way to learn. And I'm going to emphasize having you do stuff as much as possible. So the bulk of the grades in this class is all about the MPs and all about the prairie. Learn a few phrases and homeworks. The homeworks are all mastery-based. The trailer and homeworks, you don't lose points for getting a question wrong on the homeworks. So you can do your best work. Logan the answer and see whether our answer is correct. And then if you get it wrong, you'll get a new variant. If that same question, you'll have to complete the new variant a few times. So basically, e.g. the homework that's out at 02:00 P.M. today, have you add binary numbers together. So if you miss it, you'll lose it. You won't lose any points. And you'll just have to earn ten points on the problem to get full credit. The first time you get a question, correct? You get one point. If you get two in a row, you get two points. And I made it grow exponentially. So if you get three in a row, you get four points. If you get four in a row, you get eight points. So if you're getting a number of them in a row, you're going to see your points accumulate very, very quickly. So it may, so it's not like, Oh, I have to use problem ten times. But if it's something that you're struggling with, like maybe you're not really sure about the concepts. So you're getting one right, you're getting one wrong, you're getting one right, you're getting one wrong. Every time you get one wrong, you reset back to that one point. So basically, as soon as you get a winning streak, you start to basically get the points to get 100%. It's going to feel a little repetitive if you already know this stuff. But because the exponential scaling, you'll get to the total number of points very quickly. And I think it's a great learning tool. If you're not sure about it. There's two exams, they're both CTF exams. You will be programming in the CBT up. These exams require you to actually write code in the CBT. I will give you practice exams will give you a heads-up about exactly what you expect. But these exams are primarily based on your coding on the exam. So the best way to be successful at coating on the exams is having done the MPs and understand what is going on in the NPVs. So I wanted to make sure you knew right now the exams in the CTF are code-based. You will be writing C code, you will be writing Python code. You will be needing to understand what you're doing coding wise. And then the last thing is the final project I mentioned, we will be doing that at the end of the semester. And I actually have one correction for the handouts. So if you have a handout, the first batch of handouts I printed, I actually looked at the table wrong. So the final exam. So this is on the first page of your handout. You can look under the final project. If your handouts has Friday, May 5th, cross out Friday, May 5, and right. Monday, May. So I looked at the university. The handout online is correct. Cross out Friday, May 5th, except final exam based on the university calendar is Monday, May. It is in-person. You'll be running your code and collaborating with everyone else in the room. You are required to be there. It's when the university set our final exam time. If you can't be there. If you already somehow bought your tickets to leave literally the day reading day starts, you should drop the class. I don't know. The final exam is Monday, May 8th. You need to be there. That's the beginning of exam week. So it's not too late. Make sure as once you're done with this Tuesday morning, you are done with 225, are done with 340. So on Tuesday morning you're done with 340, you won't have anything else to do. So Monday, May 8th, though, you need to be here. You'll be doing your final project. So any questions on the course, overview or expectations of the course, like what you're doing in here. Any thing that's not clear. Awesome. And let me know if I missed your hand. This room isn't awkward. So I love this room. I love how much space you have. Yeah, The the class should be outright now. The first assignment and launches automatically at 02:00 P.M. so you should have an empty at 03:40. If it's not out, I will make sure it's out as soon as I get done with lecture. And I'll give you a direct link to it as well so that if you can't find it, you have a direct link. They change up prior to learn. I know it's gotten from.org.com, so I know things have changed in prairie learn. I also know 128 has a really weird junk system. So if you log in, you have to login with Illinois instead of login with Google, I think one-twenty it has you login with Google, log-in with UIUC. I know they've changed some things so you can't find the priority. Learn, we will post on Discord, will help you out who I'm speaking. So the primary way, so we'll have these lectures every Tuesday and Thursday. And then outside of lecture, we're going to use Discord as our primary mode of communication. I think so we use this last semester, it worked out really, really well. We will if it fails miserably. I'm totally up to changing this. I've already created discord. Discord is private just to us. Normally everything's going to be on this 340 course website. But there's gonna be a few things in Canvas that are personal to this course. So one of that is on Canvas. You're going to find the CSS3 40 discord link. So join that Discord, you'll actually be required to interact with that discord is part of MPI zero, the MP that we'll talk about it in class. So we've got this discord. It's, I really feel that one of the most important things, I think this is really true after the pandemic is just each other. That you guys are all literally some of the smartest computer scientists in the world. You're here at the University of Illinois. And when I think of how I got. A number of the positions I had, an industry and academia. Half of it was having the right skills and half it was knowing people who were already there. There's no better way to get a job at Google or anywhere else than having somebody who is a year or two older than you having gone to Google. And when there's recruiting season comes along, they say, Hey, what's your name? Akash. Akash, the amazing, of course, the best programmer ever worked with. And if somebody can vouch for you like that, that they know a Karsh and they know Carson, amazing programmer. That is huge. That gets you a job. And the way to do that is to meet people. Anything. A great way to meet people is through this class. So everything is gonna be collaborative based. We're going to encourage you to help each other out. We have a collaboration policy that we'll talk about with the MPs. You have to do all the MPs by yourself, but we don't want to limit high-level discussion. And in fact, we want to encourage you to kinda help each other debug. So I think getting to know each other and having a community of people who you know each other awesome and they are building each other up is the goal of this course and hopefully discord will be part of that. The other thing is, I know all of you guys made it to this classroom. I know you were able to figure out the Siebel Center for Computer Science is not the Siebel Center for Design. And you were able to make you were able to navigate to north campus that I south campus. And you're able to find 14 one-four. So I know you and know how to read and I know you're no, I know that you are really intelligent. So everything else on the course website, you can just Google search the S3, 40, I think Google's still thinks all 2022 is the one of the top results. But at the top of fall 22, I have a link to Fall 23. I can just do this Google searching real fast. So CSS3, 43, 40 kilocalorie, you find the website link here. If you end up in the previous semester, do you live in the fall 2022 is a purple page. So if you see a purple page, you're in the wrong spot, but you'll see the link right at the top to find the orange page. So this semester's color is orange and you're going to find 340. So that is all the logistics that syllabus week done in 35 min. Any questions before we get started? Working ahead now from today's lecture right here on the course website. So if I click lecture handouts 0 as in a physical document, Got you. They will always, the physical document will always be in the back of the room. I just happen to have some extras right here. Yep. Cool. Any other questions? Great question. All right. Then let me know if I'm ever missing anyone, especially in the back. Shout out if you're like, Hey, look at me. So I wanna go ahead and get started talking about the very basics of how computers think and what we're gonna be covering this class. So I wanna give you a broad overview of where we're going. So I'm gonna kinda lay out the blueprint of this entire course and what you're going to be learning by the end of this course. And then we're going to start on the very basics of computer architecture. And depending on your background, you may the first couple of weeks, maybe somewhat of a review to you, but I can guarantee you by week three or week four ones we dive into systems. Almost everything you'll see is new. So if you have done some of this architecture stuff, bear with me for a couple of weeks. I just want to make sure we're all on the exact same page. But we're gonna be talking about foundations of computer system. I'm gonna go through six different foundation that we're going to cover. And this is the order which we're going to do a deep dive and understand the topics in each of these areas. The first foundation we're going to talk about is the most important foundation, and that is data. Foundation number one is data. And this first foundation is the zeros and ones that make your computer on and do useful things. I think one thing that you may not realize, it's a lot of people think about data edge just like images, just files, or just documents or databases. But the actual execution code that happens on your computer is data. So e.g. when your CPU needs to add two numbers together, it literally sends the number for, it sends the bits zeros, zeros, 000100. This is the opcode for add. When you want your CPU, or it's one of the opcodes. There's actually six different opcode said. But if you want your CPU to add two numbers together, you're literally giving that CPU the number four. And that number for activates the circuitry to add two numbers together. That is data. That is what your programs, you've been written in Java in C plus plus, as you have three plus two, plus sign becomes an opcode. And the UPC code instructs the CPU to actually add two different pieces of memory together and put the result in some other piece of memory. That data is not just images and text. Data is actually how your computer runs. So it's really important to actually have data and you have an understanding of exactly how we're going to represent data and all of the different features of data itself. So we'll talk about op codes. We'll talk about all of the different intricacies of data and all of the different types of data files stored and how are different elements of file stored? Once we talk about data? Well, data by itself is pretty useless on a computer. If we just had a storage device, we don't have something fancy. Second Foundation is going to be your actual central processing unit or CPU. The CPU is incredibly dumb device when we get down to it. Outside of computer scientists, people think the CPU is the brains of the computer. Literally the CPU does one thing always CPU does is it takes an opcode. So it takes an operation code and does a predefined action. So all the CPU does is it has, it has a big table of op codes. On a 64-bit CPU. What makes us a CPU? 64-bit is an opcode, and all of its operands are 64 bits and law are 64 bits long. Means we have 64 bits to give an opcode and any other arguments we want with the opcode to the CPU. And on a 64-bit processor, we're able to give 64 bits of information to the CPU. That is considered a CPU word. And the word of the CPU is the length of the bits of the CPU. So if you have an old-school 32-bit CPU, reward is 32 bits. If you have a new school, 64-bit CPU, the word is 64 bits long. On a lot of graphics cards, they do lots of parallel operations. And you'll see modern graphics cards have CPUs that are like 384 bits long. So number of bits, the size of each word gets larger and larger. And if you need a lot of parallel instructions, you need a lot of parameters. Say, which different pieces of memory do you want to parallelize this operational? Cpu words are gonna be the bits of the CPU. And the CPU does. It's extremely done. It takes an op code, looks up what that code doesn t table and execute that code and hardware. Opcode for add, subtract, divide, multiply, shift. Then we'll talk about some of the more fun op codes. Like you may have all codes that are a check-in, Check-in set. So you want to check if a bit it's set to some value, and if it's not, you set it to a value. There's various different opcodes are going to use to do different hacks inside the computer. You'll understand what the different opcodes provide. And we'll go into how you might design a basic CPU. And we're gonna get to the point of designing an adder, doing that opcode 04 and then saying everything else from there. You can sit down and design it. But we're not going to spend a lot of time on designing the CPU. We're going to show you how you might add two numbers together. And then from there you can imagine how you might multiply, how you might divide, how you might do all of the other operations that you might want to do on African talking about the CPU. We want to go and we're going to realize that the CPU is really dumb and relies on data, but initially the CPU has no data. The third foundation that we're going to talk about, you're going to talk about where does this data all come from inside your computer. So third foundation is memory and storage. So we're going to make a differentiation between memory and storage in this class. And this differentiation is going to be true throughout all of computer science that we're going to call memory data that exists temporarily. Data on a temporary basis. So that's going to include things like a CPU cache. So every CPU stores a little bit of data on its processor. The data that it's most likely to access Next, it's going to store it right there on the CPU. So it has really, really fast access to it, CPU cache or extremely fast, but extremely limited. There's usually, in a CPU cache, There's megabytes of data. And the other form of memory that's common is RAM. Random Access Memory. This your main system's memory. Usually memory on a system is measured in gigabytes. So you might have, on a cell phone, you might have four or 6 gb of data flagship phone, and I have eight or ten of memory. Low-end smartphone might have like 2 gb of memory. And then a computer is going to have probably 8 gb minimum, I would say for a decent laptop, 16, 32 is probably not uncommon. You're going to have gigabyte train range of memory, memory. Data memory doesn't get stored anywhere. Here's your computer store that turn the computer off, the memory is gone. It's temporary storage, on the other hand, is permanent data storage that persists over time. So storage is going to be things like your solid-state drives, your hard disk drives. And if you're in Cloud scale systems, you may actually have these large capacity. You may have network storage. You might have things like S3. And if you're actually Amazon and you're actually storing all this data in S3. You have things like tape devices. And these generally range and the order of terabytes down to bytes plus S3 has virtually unlimited amount of storage. You can stick as well. And as long as you're willing to pay Amazon, Amazon is going to basically buy the storage so you can stick as much data as you want an Amazon as long as you pay for. So generally you're going to have a few terabytes on a hard drive, all the way up to tape drives easily have petabytes of data that you can store on it. You just get massive amounts of storage as you get offline storage. And Alaska and other parameter we're going to look at is the fact that memory is generally fast. Storage, generally slow. And there's a paradigm where there's some really fast memory, There's some less fast memory, there's some faster storage, there's some really slow storage. So that's gonna be the paradigm is going to look at. Really think about how do you want to store your data? If you're building next Instagram, where do you want the user account storage? You want that in a faster storage and the photos. So you may have different types of content your application, and you may want to use different types of storage systems. Because the cost of storage also matters. That memory is generally very, very expensive. Storage is very cheap per gigabyte. So you've got this trade-off that if you have these large photos, are these large videos, maybe you don't need fast access time, but maybe you want to store a lot of effort. So these are the things that you get to think about, not how it actually program, but how do you actually apply what you know about programming to these interesting concepts? The fourth foundation is peripherals. So this is literally everything else. So the graphics card, the printer, the mouse, the monitor, the keyboard, the touchscreen. All of these different things are peripherals. We'll talk about how they're, usually, they're almost always ran by the operating system, interfaces with the operating system. And it has use device drivers. So pretty much every peripheral outside of your CPU and outside of a ram is going to have some device driver that tells the operating system how that device actually works. Often you'll be able to just plug it in advice and I'll install the device drivers, some default device driver for you. But there's gonna be some device driver that's involved in running every peripheral. Difference is CPUs and memories. They just work. Everything else needs device driver. We won't dive deep into device drivers. You could take entire courses on each piece of hardware. Foundation is the actual operating system itself. The operating system primary job. How do we manage and share? Or hardware? With many apps? Your operating system is a key important idea because when you use your iPhone or your Android device, when you use your smartphone and you are like, Oh man, I'm really craving planning that sketchy game. What's the most? Should we hit on attention this semester? All right, It sounds like we should. All right, so I really want to play some tension, but I don't know if I really want to mention to have access to my bank account. So I've got my bank app and I've got Guinea and impact. So I'm relying on the fact that there's this operating system that acts as a mediator that keeps all my good friend impact stuff, indention and all by banks stuff in my bank app. And that file storage is separated by the operating system so that my bank app can't tell me how much I spend on getting an impact and get you to impact. Can't tell me how much I have in my bank account for me to spend more on kinship. So that little, that the job of the operating system is to make sure that both apps can coexist on your phone or on your device. And the access between the files into between the settings of these apps are completely isolated from one another. So the operating system is a really, really key component and it's going to also give us unified access to hardware. You're going to see that as you write programs, you're not going to care whether or not you're, when you send a network packet, you won't have to care if it's running over wireless or wired. Or five g. The same line of code from your perspective, is just going to use a networking interface. And the networking interface might be Wi-Fi, it might be five G, It might be Ethernet. But we're not going to care as programmers because the operating system takes care of that. It allows us to share that network interface card and abstracts these concepts away. And then finally, the very last Foundation on the systems level is we're going to talk about processes. So a process is running a version of the app, an instance of an app, or an executable. So when you actually build a program, you've compiled some code. You have an actual executable or an app file. When you actually run that app file, you get a process. The process is an actual running instance of your application. A process has a number of restrictions, the number of things it does, and multiple processes running at the same time. You might have a Chrome window open in one thing, and you may have your League of Legends game in another window. So you've got two different windows, both running the same time, both needing access to the CPU. And because both these programs are running simultaneously, we need to manage multiple processes running and synchronize their use. And we'll learn how when you run multiple processes, how that works. We'll do all of this in C. And the reason we do this in C is a lot of the interface that we're going to use. You simply cannot do in Python. There is no way to make a memory allocator in Python because the memory allocator and Python is done by calling out to a C program. So to actually understand how memory is allocated the operating system level, you need to be in C. The beauty of C is that C is simple. C doesn't have a single constructor. There are no such things as classes. So line one runs first, then line two. There's no constructor that's going to happen after line one runs because magic c removes the magic. In fact, I've seen a lot of people feel like they're more confidence as a programmer after they've done to see because they actually understand how the programs actually work. You don't have to worry about and we can still use object oriented design. We don't have object already magic. Then we're going to transition over to systems levels, abstractions, abstraction on big systems. The first system level abstraction going to talk about is we're going to talk about what it means to be a virtual machine. How does virtualization work? In fact, as part of this course, you're gonna get your own VM, basically your own EC2 instance, just like you could get from Amazon. And you're going to run it on the private UIUC Cloud. You're gonna have your own computer that you're gonna get to manage and do everything in width. You're gonna get your own personal VM next week. And this is where you can choose to program your MPs. You'll learn how they actually work and how the underlying technology part of virtualization, even though it's on a virtual machine, it uses the same underlying technology. We'll also talk about, I should say, virtual machines and containers. So we're going to spend expense, extensive amount of time talking about Docker and understanding how darker actually works and what is Docker provides a system and how do you build your own Docker containers? If you want to run an application all entirely in a containerized environment, how would you do that? What would you build? After we talk about VMs and containers? Well, we want to actually build stuff. Let's talk about what it means to be a service. And we're going to talk about not just services in general. We're going to talk about different types of services, or we're going to spend a lot of time focusing on one particular type of service. A very popular service in the current era called a microservice. And the big idea of a microservice, we're going to build a service that does one thing really, really well. Generally, we're never going to have a microservice over about 500 to 1,000 lines of code. We want to keep them small, compact, easy to maintain, easy for you to hand off to someone else and for them to understand what your microservices. So he's talking about VMs. We'll talk about services and microservices. And then finally, as the very last thing we talked about it very new semester, is we're going to talk about what it means to be a service versus a platform. When you say that you have a platform technology, what does it mean when we say that windows, the platform not a service? What does it mean when we say that AWS as a whole is a platform that offer services, what do we mean as a platform? What is it? What technical attributes do we talk about when we talk about platforms? So that is the roadmap to the entire semester. And now I want to spend just like the last 15 min that we have finishing up the back half the sheet, which many of you may be review. But this is kind of a key insight that we're gonna be using this entire semester long. And for many people, that this insight is something that you've never really thought about. You may have, you may have seen how these all things connect together. But we're going to look at how data is actually representing the computer. So probably since your very first computer science course, you will probably told that all data in computers represented by two things. What are they? How do we represent data in computer? Once, yes, you guys know this. So all data, the computer is a zero or a one. There's nothing fancier than, alright. We could just end class 01. But zeros and ones are kinda clunky. So we're going to manipulate zeros and ones, but we're going to find the zeros and ones are not the easiest thing in the world to deal with, but it's actually how data is represented inside a computer. Everything is a bit, but we wanted to represent different things at different bits. Zeros and ones are called binary. Binary is a base two notation. That means that once we get to the digit two, we don't have that digit anymore. So we only have zeros and ones. So normally we think about our decimal system, the system that you grew up with as base ten. So you have the number 012-345-6789. And then there is no number ten. So you have to swap over and do 10 again. So you got to carry a digit. The same idea applies to binary numbers. So one plus one, well, we don't have the digit two, so we have to carry a one and add a zero. So we get 210. We add a one again. We get to 11. And we added one again. We have 11 is an overflow, so we write down a zero and we carry a one overflow, right? Non-zero but a one. And that's equivalent to numbers 123. So we've got these basic numbers that just like any other numbers we just add just like normal. We're not breaking any rules. Everything you've known before it works the same except for you're not allowed to write the number two or any number higher than that, you have to carry a digit. And just for clarity like zero is just zero. So you may see the number zero. We can look at a number and we can actually look at the place value of a number. So you may be familiar with this in the decimal system where you have the ones digit in the tens digit, the hundreds digit, the thousands digit. And that's because there's a place value to every single one of these digits in the binary system works the exact same way that you have a place digit for every single digit. And we actually call this fit at the very lowest value, the least significant bit, or the LSB. You're going to see this in technical documentation all over the place. In fact, for AMP2, when you read the PNG documentation, you're going to see that's going to talk about what's in the LSB. The LSB is the least significant bit it so that contributes a lease to the number. So it contributors to 20. And it's two zeros because we're in base two. Base two says it's to the zeroth power. And then the digit that contributes the most are the basic contributes the most to the digit, to the number is the most significant bit, or the MSB. So you've got the least significant bit on the far right-hand side, the most significant bit on the far left-hand side, it's the bit that contributes the most to the value of the number, then contributes to the x power, where x is the position of that number in a bitwise order. So what we're gonna do is we're going to first convert all these to the x power is two regular numbers because I'm, I'm a human. I don't really think in binary that much. So two zeros, 122 first is 24816, and we basically have the place value for each number. And what we're gonna do is we're going to multiply the binary value. I'm going to multiply this with the place value. So zero times one is 00 times two is 00 times four is 01 times eight is 81 times 16 is 160 times 32 is 01 times 64. 64. So now we have the actual value that each bit contributes to the final number. And the way we get the final number is simply adding up all these individual values. So you have 64 plus 16 plus eight. So I've got 64, I've gotten 16, I've got eight. I simply want to add all these together. So these two together make 80 plus eight. So this binary number 1011000 is equivalent to 88 in base ten. So this is binary addition, or sorry, binary conversion. So we can convert any number over from binary to its decimal equivalent. Pretty straightforward. And I've got one practice problem on a sheet for you too if you want to work on that. But we can also do the reverse. We can also take a decimal number and figure out what is the binary value equivalent to that number. For that, I usually think of my place values as how many ones do I need? How many twos do I need? How many fours do I need? How many eights do I need to get a number? So when I think about four, I know the place values I'm allowed to have in binary is gonna be 12 or written the other way, 1 248-163-2604. Those are different place values. I have to get a four. I need I just need a four. So that's a four plus nothing else. So I know that I knew zero 1's zero, 2's N14. Because I need one for, I need the place value of four to be a one, I need all of the other place values b is zero. I could have a bunch of leading zeros, but leading zeros aren't necessarily because everything before the most significant digits just considered to be a zero. So this is binary number 100. So that little subscript two is not something that you're able to write in a computer program. If you pull up VS code, there's no subscript two button. You have to use latex and do some weird syntax. If you wanted to write subscript two. So what we do in programming languages is we prefix the number with zeros if it's going to be in binary. So if you're writing this binary number encode, you would write 0100. This works in C, This works in C plus, plus, this works in Python. There's works in any programming language. It's universal. Zero B means the number that I'm about to read after that is a binary number. So that's how you can type the binary number. 100 inside of C. Seven is similar. I need a for any a 2.1, that's gonna give me seven. That's going to be a one-to-one, one-to-one or OB 11118. What I usually do is I say what is the most significant power of two I can take from 18. What would that be? 16. So I need 116 and what's left over two? So that means I need a 16.2. So I need to know one's a two, no 4s, no eights, and one-sixteenth. So I need 10010. I can also write that in binary notation for computer as 10010. So this is binary numbers. Any questions on zeros and ones? So I hate zeros and ones. They're long, they're clunky. They're hard to say. I'm saying 01100011, blah, blah, blah. It's a lot. So there might be a better system. But before I do that, what you have is every single lecture, I'm going to have code that goes along with the lecture because I don't want you to really believe anything. I say. I want you to be able to run this code. So I have this code that is available on where did the font go? I should be sorry, wrong font Somehow. My computer doesn't have the fun to use. So if you look at this program, I've got this program available in the lecture webpage. And you're going to see for every single lecture there's going be a corresponding code. When the examples get crazy complex, we will run some of this code and I'll have VS code up. So we can see that this binary.ci can have the binary digits and Visual Studio Code has no problem thinking. I'm thinking of them as digits. So binary is a little bit cringe. It's a bunch of zeros, It's a bunch of ones. And we can do better. So this is the string for the number of students at the University of Illinois. I can go through and figure out what the place value for every single one of those things are. But is there a nicer and easier way to represent this number in a way that can still be easily converted back to binary. And the answer is, yeah, I think we can. So what we've done is we've introduced a, we're going to introduce a new system of numbers. This is gonna be a primary system of numbers that we use to represent data on our computer. And it's a really genius system of numbers and a genius for so many different ways. So what we're gonna do is we're gonna make a number system that is base 16. Hexadecimal is a base 16 number system. And what that means is we need the digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and 0. Okay? We could use a digit ten, but that's two characters long. That's a little awkward. So any suggestions on what we should do now that we're out of numbers? What comes after nine? What do I want to use? Letters. Okay, what's the first letter? Alright, so let's go ahead and start just using letters. And then we'll say the number, the digit for the number ten is a. So a is sort of our ten years or 11 or 12 days are 13 or 14, and F is R 15. And now we can get to 16 because we're base 16. So now we have all the possible digits and they run 0-9, a to F, and we're going to call them digits because that's where they are. They represent a numerical value at a particular place. And everything we talked about, place value stays exactly the same. So my favorite hex decimal word is the word coffee, C0, ff, EE, perfectly valid hex decimal. And we will see as hexadecimal that represents something as a hex. Instead of using OB, use OX, that's your hexadecimal indicator. It says everything after that OX will be a number that's in hex decimal format. The idea of place values exactly the same except for the place value. Now it takes 16 to the x power. So we can do the exact same thing we did before by saying 60 and the zeroth power, well, that's just one, that's 16, that's 256. This is some large number. So we can give me. There we go. Go ahead and look at what the place value is for each of these things. So that's going to be e, as we said, is gonna be the digit 14. 14 times ten to the 16th to the zeroth power is going to be 14 plus E is fortunate here, so that's gonna be 14 times 16 to the first power. So that's gonna be somewhere around the number 200. And we can go through each of these, figure out what the value is to eventually get to. The place value, or the decimal equivalent to the word coffee Is, is equal to all of these numbers added together. And we eventually get to 12 million. Or 648,430 is the decimal equivalent to copy. The big thing to understand is this just the same place value equivalent as we did with binary? There's nothing special at hex decimal except for we're now in base 16 instead of base two. And you can do this in octal, which is base eight, or any other base on. We'll actually talk about base-64 later because that's kinda the format we used in the web. Talk about base-64 encoding. We're gonna deal with a lot of basis throughout this class. And they all reside on this basic idea of place value. So what we can do now is we can look at what the equivalent to any decimal number is in the hexadecimal representation. Number 11 in decimal is now simply one of our letters. So what did we say 11 was, yeah. So this is hexadecimal be it doesn't matter if you use all caps or all lowercase. I prefer the lowercase representation of the letters. If you want to say capital B, that's totally fine. Just be consistent. Either use all lowercase or all capital. Doesn't matter if you use lowercase b and capital B computers will accept both of them. I'm 34. So how many 16s can we take from 3042. And how many do we have leftover? What's the remainder? Two? Yeah. So 34 is 16 times two plus two. That means we need two 16's. And then we have two leftover. Super important to have that OX notation because that's not the number 22, That's number 34. That's the number 34 in hexadecimal and decimal number 22 in hexadecimal. So 87, same idea. How many 16s can we take for maybe 75 of them. What's the remainder? Seven. Yeah, So we have five times 16.16 times five plus seven. So that's gonna be hexadecimal 57.2, 55. How many 16s can I take from 255? Oh, this seems hard. Is there an easier way? What's actually the next one above 16? What's the next place value to 56? So I actually think of this problem as this is equal to one to 50,606.01 minus one, right? Because 256 was 100. Subtract one from that, we're down to 55, right? So what's the digit right before 100? If we were taking 100s, subtract one, we get What's the max digit we have in hex decimal, right? If you think of like if you can do 100, you get to 99, the max digit, then you roll around to 100 and hexadecimal the maxillary right is f, f. So you have the digits FF. So we have the hexadecimal equivalent. And what we can do, and what's genius about hexadecimal? Is, hexadecimal is particularly genius because it has a four bits every single digits. So this is what's beautiful about design, is hex always has x has four digits. Every, are, sorry, for binary bits, four bits every digit. So what we'll often do in binary, we are going to group the binary together in sets of four. Because every single four binary bits is always equivalent to a single hexadecimal digit. So what that means is this 101-111-1248, that's eight plus two plus one. That's 11. So 11 we said was the letter B. This is four plus two or six. This is eight plus 412. Let her see. And this is eight plus four, which letter C? So this binary number number students at the University of Illinois last time is reported, which was last fall. Is C6 be in hexadecimal. We're able to take that disgusting binary number. And representing something much more compact, doesn't matter how large the number is. Some of you guys may know, you guys know who my favorite celebrity is. Taylor, Okay. Yes. So there's gonna be a lot of Taylor references. So one thing I'm always wondering is how many people are following Taylor Swift on Twitter or Instagram. She's got that many followers. She's rocking it. I mean, we can convert the number of followers just like anything else to hexadecimal. So we can say this is zero, this is simply a two, is simply a for an 82.1, is this 11 or a be an n and a two or ten. So this is a, this a 4.1 and five. And this is a. So we're able to convert any of the binary digits by simply grouping them into four and converting them to their hex equivalent. So it's a pretty simple translation. And because memory addressing them being 64 bits long, we'd much rather write them out as nice little hexadecimal digits. So you're going to see a lot of numbers we represented on the computer. We're going to represent as hex decimal because it's very easy to convert between that and binary. So we can add things up together. So I'm wondering like coffee plus food, I can add two hexadecimal digits together and get a result. What I'd love to know is there to like hexadecimal words you can add to make a new word. That's something I'm working on. So we can add the digits together. I want to leave you with two things that we have. So I want you to experience the first mastery-based homework. So at this afternoon, I will have homework one available for urine prior to learn. Just like I explained on top of class, it's going to be a mastery-based homework. Well, you'll finish. Well you demonstrate that you understand what's happening in lecture. The other more important thing is we have a preempt P0 that we're releasing today. There's an MP that's available for you, and this is called MP zero. This is the easiest MP of the semester. This is your computer setup in P. You're going to develop on your own computer. There's no Docker container we're giving you. We're not holding your hand. You're going to install VS code on your own computer. You're going to install a C compiler on your own computer. If you're on Windows, you're going to use WSL. You are going to begin to actually understand how to use your system. Np zero is your pre and p. It doesn't involve programming. It's the only MP where you don't have to program. Instead you're going to use the debugger. You're going to learn how to use a debugger. You'll have all of that out this afternoon. They're both due next week. The homework is due next Monday, the NP is due next Tuesday. I'll be here after lecture if you have any questions, otherwise, have an amazing couple of days. I'll see you guys back here on Thursday. See you then.